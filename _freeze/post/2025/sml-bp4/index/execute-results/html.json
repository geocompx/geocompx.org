{
  "hash": "f3b7d28b2a84a9ce2134d5e8457be663",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatial Machine Learning with mlr3\"\nauthor: \n  - name: Marvin Ludwig\n    orcid:  0000-0002-3010-018X\ndate: \"\"\nslug: sml-bp5\ncategories:\n  - rstats\n  - sml\ntags: [caret, CAST, mlr3, tidymodels, machine-learning, spatial-machine-learning]\ndraft: true\nmermaid-format: png\nknitr:\n  opts_chunk:\n    message: false\n---\n\n\n\n::: {.callout-note appearance=\"simple\"}\n\nThis is the fourth part of a blog post series on spatial machine learning with R.\n\nYou can find the list of other blog posts in this series [in part one](post/2025/sml-bp1/).\n\n:::\n\n## Aims of this post\n\nThis post aims to give a minimal example on how to use **mlr3** for a spatial prediction task. \nWe want to get from measurements of temperature at specific locations in Spain to a spatially continuous map of temperature for all of Spain. \n\nSuch a spatial prediction task is often done by applying machine learning algorithms that are not necessarily developed for spatial tasks specifically and hence do not consider problems we might encounter in the spatial world, e.g., spatial autocorrelation or map extrapolation. \nIn the last decade, a lot of methodological developments were made by various research groups to consider and deal with such specialties of spatial mapping. \nMany of which found their way in software packages such as **mlr3**.\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"mlr3verse\")\ninstall.packages(\"mlr3spatiotempcv\")\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\n```\n:::\n\n\n\n### Casestudy data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncovariates <- terra::rast(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/predictors.tif\")\ntemperature <- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg\")\n\nspain <- sf::read_sf(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/spain.gpkg\") |>\n    st_cast(\"POLYGON\") |>\n    st_transform(st_crs(temperature))\n\ntemperature <- terra::extract(covariates, temperature, bind = TRUE) |>\n    sf::st_as_sf()\n\n# the sf object cannot contain a column named \"X\" or \"Y\". Otherwise the task creation will fail because \"Assertion on 'data' failed: Must have unique colnames\"\ntemperature$X <- NULL\ntemperature$Y <- NULL\n```\n:::\n\n\n\nSome words about the terminology that is specific to the example data:\n\n- `spain` is the region outline - for visualization purposes and kNNDM setup\n- `covariates` are the spatially explicit data data to predict on (to prevent wording confusions with the predict function or the prediction)\n- `temperature` are the measured temperature data (i.e. the response variable, i.e., the ground truth) along with the covariates at the measurement location\n\n### Official Documentation\n\nThe best general introduction to **mlr3** is probably the official **mlr3** book which you can access for free here: <https://mlr3book.mlr-org.com/>.\nThe homepage <https://mlr-org.com/> also gives a very detailed overview of all the associated packages an current developments.  \nThe individual packages also have their own documentation pages, where you will find more specific topics. \nThe \"spatial\" packages are the following:\n\n- `mlr3spatial` implements support for spatial data types in R -- <https://mlr3spatial.mlr-org.com/>\n- `mlr3spatiotemporalcv` implements spatial cross-validation methods in the workflow -- <https://mlr3spatiotempcv.mlr-org.com/articles/mlr3spatiotempcv.html> -- and also uses the `mlr3spatial` package for the spatial data types handling\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlr3verse)\nlibrary(mlr3spatiotempcv)\nlibrary(mlr3viz)\n```\n:::\n\n\n\n:::{.callout-hint}\n**mlr3** functions can be very verbose. \nFor this blog post, I turned off messages for a less overwhelming tutorial.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\nlgr::get_logger(\"bbotk\")$set_threshold(\"warn\")\n```\n:::\n\n\n\n## Getting started with mlr3\n\nFirst of all, **mlr3** uses `R6` classes and therefor an object-oriented design paradigm. \nThis might be not intuitive for a lot of R users and more in line with something like scikit-learn of Python.\nIn general, with `R6` classes you define an object first, and this object contains all the methods and parameters you can access.\n\nThe `R6` class in R has a significant drawback when it comes to RStudio's convenience features. \nFor example, it does not provide in-line popup help for available parameters in a model. \nThis means you must manually look up the parameters, e.g., needed for the `ranger()` function.\"\n\nLet's define a minimum spatial prediction task example with **mlr3** classes:\n\n:::{.callout-hint}\n**mlr3** uses its own terminology. \nYou have to know a lot of specific terms in order to comfortably use the functions. \nI try to use the **mlr3** terminology here and give some alternative terms in parenthesis.\n:::\n\n### Task\n\nThe `task` defines general information about the data we have at hand. \nFrom our point observations we create the task and define what column the target (response / dependent) variable is, what column the geometry (coordinates) is and whether we want to use the coordinates as features (predictors). \nIn this example, we also split the data in our task into a training and a test partition.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntask_spain <- mlr3spatial::as_task_regr_st(\n    temperature,\n    target = \"temp\",\n    coordinate_names = \"geometry\",\n    coords_as_features = TRUE,\n    crs = st_crs(temperature)\n)\n\ntrain_test_split <- mlr3::partition(task_spain, ratio = 0.7)\n```\n:::\n\n\n\n:::{.callout-tip}\n## `st_drop_geometry()`\nIn **caret**, if we want to use spatial data, we have to specifically exclude the geometry column of the `sf` object. \nWe lose the spatial information in the process of model training and prediction. \nHowever, this information can be critical, e.g., if we want to use `CAST::errorprofiles()` or `CAST::knncv()`.\nIn **mlr3** we can keep the geometry and can also directly define whether we want to use the coordinates as predictors.\n:::\n\n### Learner\n\nThe `learner` is the model type or algorithm we want to use with all its necessary or optional parameters. \nHere I define a Random Forest regression method from the **ranger** package with 100 decision trees and an `mtry` of 4.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrfmodel <- mlr3::lrn(\"regr.ranger\", num.trees = 100, mtry = 4)\n```\n:::\n\n\n\n### Measure\n\nIn order to evaluate the a score (model performance), e.g., from the previously defined test data partition, we need to define a `measure`.\nHere I use the Root Mean Squared Error (RMSE).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeasure_rmse <- mlr3::msr(\"regr.rmse\")\n```\n:::\n\n\n\n## Training, Validation and Prediction\n\nWe now have everything defined to actually do something. \nTo train the model we can use the `train` method from out defined learner. And we have to tell the `train` method on what to actually fit the model -- in this case the data in `task_spain`, but only the subset we sampled as training data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrfmodel$train(task_spain, row_ids = train_test_split$train)\nrfmodel$model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRanger result\n\nCall:\n ranger::ranger(dependent.variable.name = task$target_names, data = task$data(),      case.weights = task$weights$weight, mtry = 4L, num.threads = 1L,      num.trees = 100L) \n\nType:                             Regression \nNumber of trees:                  100 \nSample size:                      136 \nNumber of independent variables:  22 \nMtry:                             4 \nTarget node size:                 5 \nVariable importance mode:         none \nSplitrule:                        variance \nOOB prediction error (MSE):       1.171878 \nR squared (OOB):                  0.8521981 \n```\n\n\n:::\n:::\n\n\n\nTo test how well out model performs now on unseen data, we use the `predict` method of our fitted learner. \nAgain, we tell the `predict` method on what data to predict. \nWe can then calculate the `score` of this test prediction, i.e., the RMSE we defined earlier as out measure. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_prediction <- rfmodel$predict(task_spain, row_ids = train_test_split$test)\ntest_prediction$score(measure_rmse)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nregr.rmse \n0.8742688 \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(test_prediction)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mlr3-prediction-tabular-1.png){width=672}\n:::\n:::\n\n\n\nFinally, we can also use the model to predict temperatures for the whole raster by using the `predict()` function from **terra**. \nAlternatively, we could use `predict_spatial()` for the **mlr3spatial** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction <- terra::predict(covariates, rfmodel)\nplot(prediction)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mlr3-prediction-spatial-1.png){width=672}\n:::\n:::\n\n\n\n## Spatial cross-validation hyperparameter tuning\n\nIn many cases, the ideal model hyperparameters are not obvious and we have the possibility to tune them based on the data we have.\n\n### Define the c-v strategy and hyperparameters\n\nAgain, we first define the necessary **mlr3** objects for our tuning process. \nWith `rsmp` we decide on a resampling strategy, i.e., the data partitions we use as cross-validation folds. \nThe package **mlr3spatiotemporalcv** contains the popular spatial resampling strategies such as block CV (`spcv_block` used in the example below) or kNNDM.\n\nFor the `learner` instead of predefined hyperparameters, we use the function `to_tune()` where we can specify different values for the hyperparameters we want to test.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlr3spatiotempcv)\n\nresampling_blockcv <- rsmp(\"spcv_block\", folds = 5, range = 5000)\n\nrfmodel <- lrn(\n    \"regr.ranger\",\n    num.trees = 100,\n    mtry = to_tune(c(2, 4, 6, 10, 12)),\n    min.node.size = to_tune(c(5, 10, 15)),\n    importance = \"impurity\"\n)\n```\n:::\n\n\n\nNow we can assemble everything together in a `tuning instance` object with the `ti()` function.\nThe first four arguments should be self explanatory: `terminator` means, if we want to stop with our search for the best hyperparameter combination after some criteria is met. \n`store_benchmark_results` and `store_models` regulates whether we want to keep the measures and models for all the hyperparameter combinations we test.\n\nFinally, we have to decide on a strategy on how to search with the `tuner` object. \nHere I use `grid_search` which is the brute force method that tests every possible combination once. \nWe then execute the cross-validation with the `optimize` method from the `tuner` object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntuning_blockcv <- ti(\n    task = task_spain, # the data\n    resampling = resampling_blockcv, # the folds\n    learner = rfmodel, # the rfmodel with mtry and min.node.size to tune\n    measures = measure_rmse, # how to measure performance\n    terminator = trm(\"none\"),\n    store_benchmark_result = TRUE,\n    store_models = TRUE\n)\n\ntuner_grid_search <- mlr3tuning::tnr(\"grid_search\")\n\ntuner_grid_search$optimize(tuning_blockcv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   min.node.size   mtry learner_param_vals  x_domain regr.rmse\n          <char> <char>             <list>    <list>     <num>\n1:            10     10          <list[5]> <list[2]> 0.8727164\n```\n\n\n:::\n:::\n\n\n\nThe results are stored in the defined `tuning instance` object. \nWe also have some nice plotting options with the **mlr3viz** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntuning_blockcv$result_learner_param_vals\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$importance\n[1] \"impurity\"\n\n$num.threads\n[1] 1\n\n$num.trees\n[1] 100\n\n$min.node.size\n[1] 10\n\n$mtry\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\ntuning_blockcv$result_y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nregr.rmse \n0.8727164 \n```\n\n\n:::\n\n```{.r .cell-code}\nautoplot(tuning_blockcv, type = \"parallel\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/spatial-cv-results-1.png){width=672}\n:::\n:::\n\n\n\nBecause we set `store_benchmark_result = TRUE` and `store_models = TRUE`, we also have a `archive` where all the other results are stored.\n\n::: {.callout-tip collapse=\"true\"}\n## Tuning Archive\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntuning_blockcv$archive$data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    min.node.size   mtry regr.rmse warnings errors runtime_learners\n           <char> <char>     <num>    <int>  <int>            <num>\n 1:            10     10 0.8727164        0      0            0.237\n 2:             5      2 1.0612209        0      0            0.151\n 3:             5     12 0.9025742        0      0            0.413\n 4:             5      4 0.9718021        0      0            0.209\n 5:            10      6 0.8981735        0      0            0.193\n 6:            15      2 1.1555988        0      0            0.141\n 7:            15     10 0.9061243        0      0            0.215\n 8:            15     12 0.9080667        0      0            0.238\n 9:             5     10 0.8799594        0      0            0.328\n10:            10      4 0.9894942        0      0            0.165\n11:            10      2 1.1106076        0      0            0.131\n12:            15      4 0.9530194        0      0            0.144\n13:            10     12 0.8903134        0      0            0.270\n14:            15      6 0.9659378        0      0            0.175\n15:             5      6 0.9194231        0      0            0.224\n                                   uhash  x_domain           timestamp batch_nr\n                                  <char>    <list>              <POSc>    <int>\n 1: 131c9e16-a48f-4c7b-8a99-7a1f70f1061e <list[2]> 2025-04-27 16:32:46        1\n 2: 1bc7769c-81d2-476d-9f87-3cbdd0bccedf <list[2]> 2025-04-27 16:32:46        2\n 3: bc7a3722-8d80-490a-a0ae-51b278329d54 <list[2]> 2025-04-27 16:32:47        3\n 4: 874b943d-8f6d-4f2a-b67b-d7f03d681726 <list[2]> 2025-04-27 16:32:47        4\n 5: 2720c883-d5a9-47db-b71f-10aba596201d <list[2]> 2025-04-27 16:32:48        5\n 6: 8030e57d-02da-4507-9cb5-f3f98199e88d <list[2]> 2025-04-27 16:32:48        6\n 7: 358a7251-734b-4944-b49e-0907d6caf946 <list[2]> 2025-04-27 16:32:49        7\n 8: 5b5fe61f-77ac-4be6-a490-067a7f25d29d <list[2]> 2025-04-27 16:32:49        8\n 9: 73dd9fd8-09bb-4338-b5d5-3f1f2195a900 <list[2]> 2025-04-27 16:32:49        9\n10: bd0023a2-6718-4607-a162-0137fbb0e940 <list[2]> 2025-04-27 16:32:50       10\n11: 540776f9-3edb-45f4-b5a3-94086d539e69 <list[2]> 2025-04-27 16:32:50       11\n12: 8a23040d-f4f3-4f9c-8d94-4e35e6959949 <list[2]> 2025-04-27 16:32:50       12\n13: e9ab95c0-431e-4aea-baef-4c7baa9eae61 <list[2]> 2025-04-27 16:32:51       13\n14: 023635de-6bd3-4175-ae94-2ad19065498c <list[2]> 2025-04-27 16:32:51       14\n15: d671e100-4f3f-4059-867f-0c0b15eee650 <list[2]> 2025-04-27 16:32:52       15\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Final model with optimized hyperparameter\n\nOnce we found the optimal hyperparameter combination we can use them to train a final model on all the data. \nWe define a new `learner` and assign the parameters from our `tuning instance` to it.\nThen we can train and predict again.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntuned_rfmodel <- lrn(\"regr.ranger\")\ntuned_rfmodel$param_set$values <- tuning_blockcv$result_learner_param_vals\n\ntuned_rfmodel$train(task_spain)\ntuned_prediction <- terra::predict(covariates, tuned_rfmodel)\nplot(tuned_prediction)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mlr3-finalmodel-1.png){width=672}\n:::\n:::\n\n\n\n## Feature Selection\n\n### Define the feature selection strategy\n\nSimilar to the hyperparameter tuning, we can use the cross-validation strategy to test whether we can build a model with reduces predictors / covariates / features / variable. Here I demonstrate a forward variable selection, that starts out with the best performing pair of variables and appends additional variables, if there is still an increase in our cross-validation performance estimation.\n\nFirst we have to define the feature selection strategy with `fs()`.\nI use a learner here with fixed hyperparameters. \nEverything is put together in the `fselect()` function that creates a feature selection `instance` in which all the information, methods and results are stored.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlr3fselect)\nlibrary(mlr3filters)\n\nselect_mode <- fs(\"sequential\", min_features = 2)\n\nfs_rfmodel <- lrn(\n    \"regr.ranger\",\n    num.trees = 50,\n    mtry = 2,\n    min.node.size = 5,\n    importance = \"impurity\"\n)\n\nset.seed(20)\nfeature_selection <- fselect(\n    fselector = select_mode,\n    task = task_spain,\n    learner = fs_rfmodel,\n    resampling = resampling_blockcv,\n    measure = measure_rmse\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# selected variables\nfeature_selection$result_feature_set\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Y\"         \"dem\"       \"lst_day\"   \"lst_night\" \"ntl\"       \"popdens\"  \n```\n\n\n:::\n\n```{.r .cell-code}\n# CV RMSE with the selected variables\nfeature_selection$result$regr.rmse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7795219\n```\n\n\n:::\n:::\n\n\n\n### Final model with selected features\n\nOnce we found the ideal combination of variables, we can reduce our task to those predictors, train a model and predict.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs_task <- task_spain$select(feature_selection$result_feature_set)\n\nfs_rfmodel$train(fs_task)\n\nfs_prediction <- terra::predict(covariates, fs_rfmodel)\nplot(fs_prediction)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n## Conclusions\n\n- Utilizes an **object-oriented approach** with `R6` classes, offering flexibility but requiring familiarity with this system in R.\n- Possible target audience: **machine learning experts** and **Python users** transitioning to R, especially those familiar with object-oriented programming.\n\n### Strengths\n\n- **Spatially explicit methods are directly implemented**: there is no need to exclude the geometry column of the `sf` object, allowing for the retention of spatial information.\n- **Active development**: continuously updated with improvements and bug fixes.\n- **Very good introduction to the framework through the book**: The book offers a well-structured guide for learning the **mlr3** framework.\n- **Well-documented functions**: Clear and comprehensive documentation helps users understand the functions easily.\n\n### Weaknesses\n\n- **Steep learning curve**: The framework’s complexity can be challenging for beginners.\n- **Overwhelming number of methods and options**: The extensive methods can be difficult to navigate for new users.\n- **Confusing help pages due to `R6` logic**: Understanding the `R6` logic in help files can be tough for those unfamiliar with the system.\n- **No in-line help in RStudio**: Lack of in-line help for `R6` methods in RStudio makes it harder to access function details quickly.\n\n::: {.callout-note appearance=\"simple\"}\n\nThis blog post was originally written as a supplement to the poster \"An Inventory of Spatial Machine Learning Packages in R\" presented at the FOSSGIS 2025 conference in Muenster, Germany.\nThe poster is available at <https://doi.org/10.5281/zenodo.15088973>.\n\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}