{
  "hash": "ef9190492a8b55bd7b0a02452662caef",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle:  \"Specialized R packages for spatial machine learning: An introduction to RandomForestsGLS, spatialRF, and meteo\"\nauthor:\n  - name: Jakub Nowosad\n    url: https://jakubnowosad.com\n    orcid:  0000-0002-1057-3721\ndate: \"2025-06-25\"\nslug: sml-bp5\ncategories:\n  - rstats\n  - sml\ntags: [RandomForestsGLS, spatialRF, meteo, machine-learning, spatial-machine-learning]\ndraft: true\nmermaid-format: png\nknitr:\n  opts_chunk:\n    message: false\n---\n\n\n\n\n::: {.callout-note appearance=\"simple\"}\n\nThis is the fifth part of a blog post series on spatial machine learning with R.\n\nYou can find the list of other blog posts in this series [in part one](/post/2025/sml-bp1/).\n\n:::\n\n\nThis document provides an overview of three R packages, **RandomForestsGLS**, **spatialRF**, and **meteo**, that implement spatial machine learning methods, but are outside of standard machine learning frameworks like **caret**, **tidymodels**, or **mlr3**.\n\nAll of the examples below use the same dataset, which includes the temperature measurements in Spain, a set of covariates, and the spatial coordinates of the temperature measurements.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspain <- sf::read_sf(\n    \"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/spain.gpkg\"\n)\ncovariates <- terra::rast(\n    \"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/predictors.tif\"\n)\ntemperature <- sf::read_sf(\n    \"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg\"\n)\n\ntemperature <- terra::extract(covariates, temperature, bind = TRUE) |>\n    sf::st_as_sf()\n```\n:::\n\n\n\n\n# RandomForestsGLS\n\nThe **RandomForestsGLS** (<https://doi.org/10.21105/joss.03780>) package implements [the Generalised Least Square (GLS) based Random Forest (RF-GLS) algorithm](https://doi.org/10.1080/01621459.2021.1950003).^[Quoting the authors \"RF-GLS extends RF in the same way generalized least squares (GLS) fundamentally extends ordinary\nleast squares (OLS) to accommodate for dependence in linear models.\"]\nThis approach is designed for spatial data modeling as it accounts for spatial dependencies in the data by:\n\n1. Using a global dependency-adjusted split criterion and node representatives instead of the classification and regression tree (CART) criterion used in standard RF models\n2. Applying contrast resampling rather than the bootstrap method used in a standard RF model\n3. Employing residual kriging with covariance modeled using a Gaussian process framework\n\nThe package provides four functions:\n\n1. `RFGLS_estimate_spatial()` for estimation in spatial data\n2. `RFGLS_predict()` for prediction of the mean function\n3. `RFGLS_predict_spatial()` for prediction of the spatial response\n4. `RFGLS_estimate_timeseries()` for estimation in time series data (not discussed here)\n\nThe package has rather unintuitive syntax and requires the data to be in a specific format. \nWe need to provide the coordinates of the data (a matrix), the response variable (a vector), and the covariates (a matrix).\nIn the example below, I limited the covariate matrix to the variables that are not spatial proxies.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RandomForestsGLS)\n\ncoords <- sf::st_coordinates(temperature)\ntemp_response <- temperature$temp\n\ntemperature_df <- sf::st_drop_geometry(temperature)\ncovariate_names <- colnames(temperature_df)[2:(ncol(temperature_df) - 7)]\ncovariate_matrix <- as.matrix(temperature_df[, covariate_names])\n```\n:::\n\n\n\n\nFor the example, we also split the data into training and testing sets based on created random indices.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2025 - 01 - 30)\ntrain_idx <- sample(1:nrow(coords), floor(nrow(coords) * 0.7))\n```\n:::\n\n\n\n\nThe `RFGLS_estimate_spatial()` function is used to fit the RF-GLS model.\nHere, we customize the number of trees to 100, but the function has many other parameters that can be adjusted.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimation_result <- RFGLS_estimate_spatial(\n    coords = coords[train_idx, ],\n    y = temp_response[train_idx],\n    X = covariate_matrix[train_idx, ],\n    ntree = 100\n)\nstr(estimation_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 7\n $ P_matrix        : int [1:136, 1:100] 18 78 88 123 31 80 49 67 65 98 ...\n $ predicted_matrix: num [1:136, 1:100] 17 17 13 14.9 13 ...\n $ predicted       : num [1:136] 16 15.4 10.9 13.8 15 ...\n $ X               : num [1:136, 1:15] 727 20.7 0 203.7 0 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:136] \"88\" \"106\" \"24\" \"11\" ...\n  .. ..$ : chr [1:15] \"popdens\" \"coast\" \"dem\" \"imd\" ...\n $ y               : num [1:136] 16.13 15.21 7.53 13.61 15.59 ...\n $ coords          : num [1:136, 1:2] 495960 523533 273723 618599 616251 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"X\" \"Y\"\n $ RFGLS_object    :List of 6\n  ..$ ldaughter : int [1:273, 1:100] 2 4 6 8 0 10 12 0 14 0 ...\n  ..$ rdaughter : int [1:273, 1:100] 3 5 7 9 0 11 13 0 15 0 ...\n  ..$ nodestatus: int [1:273, 1:100] -3 -3 -3 -3 -1 -3 -3 -1 -3 -1 ...\n  ..$ upper     : num [1:273, 1:100] 27.029 0.216 76.038 0.287 0 ...\n  ..$ avnode    : num [1:273, 1:100] 0 0 0 0 15.3 ...\n  ..$ mbest     : int [1:273, 1:100] 14 10 2 8 0 2 8 0 2 0 ...\n```\n\n\n:::\n:::\n\n\n\n\nThe result is a list with seven elements: a matrix of zero-indexed resamples, a matrix of predictions (ntest x ntree), a vector of predicted values, the covariate matrix, the response variable, the coordinates matrix, and the RF-GLS object.\n\nNow, we can use the fitted model to predict the mean function (`RFGLS_predict()`) or the spatial response (`RFGLS_predict_spatial()`).\nThe difference (as far as I understand) is that the former returns the mean prediction, while the latter uses the spatial coordinates in addition to the covariates to predict the spatial response.\n\nThe first function returns a list with two elements: a matrix of predictions (ntest x ntree) and a vector of predicted values, while the second function returns a list with just one element: a vector of predicted values.\nJust note that the predictions by the `RFGLS_predict()` are named `\"predicted\"` and the predictions by the `RFGLS_predict_spatial()` are named `\"prediction\"`.\n\n\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nprediction_result <- RFGLS_predict(\n    RFGLS_out = estimation_result,\n    Xtest = covariate_matrix[-train_idx, ]\n)\nprediction_result_spatial <- RFGLS_predict_spatial(\n    RFGLS_out = estimation_result,\n    coords.0 = coords[-train_idx, ],\n    Xtest = covariate_matrix[-train_idx, ]\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in BRISC_estimation(coords, x = matrix(1, nrow(coords), 1), y = rfgls_residual, : The ordering of inputs x (covariates) and y (response) in BRISC_estimation has been changed BRISC 1.0.0 onwards.\nPlease check the new documentation with ?BRISC_estimation.\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(prediction_result$predicted, prediction_result_spatial$prediction)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/misc-sml-5-1.png){width=672}\n:::\n:::\n\n\n\n\nThe final results of these two approaches are v. similar, but not identical.\n\nNow, let's predict the models' results on the whole dataset.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncovariate_coords_r <- terra::crds(covariates)\ncovariate_matrix_r <- as.matrix(covariates)\ncovariate_matrix_r <- covariate_matrix_r[, covariate_names]\n\npred_s <- RFGLS_predict_spatial(\n    RFGLS_out = estimation_result,\n    coords.0 = covariate_coords_r,\n    Xtest = covariate_matrix_r\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in BRISC_estimation(coords, x = matrix(1, nrow(coords), 1), y = rfgls_residual, : The ordering of inputs x (covariates) and y (response) in BRISC_estimation has been changed BRISC 1.0.0 onwards.\nPlease check the new documentation with ?BRISC_estimation.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in corr_pred$prediction + func_pred$predicted: longer object length is\nnot a multiple of shorter object length\n```\n\n\n:::\n\n```{.r .cell-code}\npred_r <- terra::setValues(covariates[[1]], pred_s$prediction)\nnames(pred_r) <- \"prediction\"\nterra::plot(pred_r)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/misc-sml-6-1.png){width=672}\n:::\n:::\n\n\n\n\n# spatialRF\n\nThe **spatialRF** (<https://blasbenito.github.io/spatialRF/>) package's aim is to provide a minimal code interface to fit spatial regression models with Random Forest.\nThe internal calculations are based on three general methods to generate spatial predictors from the distance matrix of the data points: Distance matrix columns as explanatory variables (Hengl et al. 2018), Moran’s Eigenvector Maps (Dray, Legendre, and Peres-Neto 2006) and PCAs.\nThe **ranger** package is used here internally to fit the Random Forest model.\n\nThis package also requires the data to be in a specific format.\nWe need to provide the data as a data frame with the dependent variable, including spatial coordinates, and the distance matrix: a matrix with the distances among the records in the data frame.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spatialRF)\nlibrary(sf)\n\ncoordinates <- st_coordinates(temperature)\ncolnames(coordinates) <- c(\"x\", \"y\")\ncoordinates <- as.data.frame(coordinates)\n\ntemperature_df <- st_drop_geometry(temperature)\ntemperature_df$x <- coordinates[, 1]\ntemperature_df$y <- coordinates[, 2]\n\ndistance_matrix <- as.matrix(dist(temperature_df[2:(ncol(temperature_df) - 9)]))\n```\n:::\n\n\n\n\nWe also need to define the dependent variable and the predictor variables.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponse_name <- \"temp\"\ncovariate_names <- colnames(temperature_df)[2:(ncol(temperature_df) - 9)]\n```\n:::\n\n\n\n\nFinally, we can fit the models using one of the methods provided by the package.\nThe package has 10 methods implemented, nine of which are based on the three components:^[See `?rf_spatial` for more details. Also, the 10th method is `\"hengl\"` directly following the approach by Hengl et al. (2018).]\n\n1. The method to generate spatial predictors (`\"hengl\"`, `\"mem\"`, or `\"pca\"`)\n2. The method to rank spatial predictors (`\"moran\"` or `\"effect\"`)\n3. The method to select spatial predictors (`\"sequential\"` or `\"recursive\"`)\n\nThe main function of this package is `rf_spatial()`, which fits the Random Forest model with spatial predictors.\nHere, an example using Moran's Eigenvector Maps method to generate spatial predictors, Moran's I to rank them, and sequential selection of the predictors is shown.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_spatial_moran <- rf_spatial(\n    data = temperature_df,\n    dependent.variable.name = response_name,\n    predictor.variable.names = covariate_names,\n    distance.matrix = distance_matrix,\n    distance.thresholds = 0,\n    method = \"mem.moran.sequential\",\n    n.cores = 1\n)\nrf_spatial_moran\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel type\n  - Fitted with:                     ranger()\n  - Response variable:               temp\n\nRandom forest parameters\n  - Type:                            Regression\n  - Number of trees:                 500\n  - Sample size:                     195\n  - Number of predictors:            15\n  - Mtry:                            3\n  - Minimum node size:               5\n\n\nModel performance \n  - R squared (oob):                  0.887361\n  - R squared (cor(obs, pred)^2):     0.9844978\n  - Pseudo R squared (cor(obs, pred)):0.9922186\n  - RMSE (oob):                       0.9476691\n  - RMSE:                             0.4131\n  - Normalized RMSE:                  0.103203\n\nModel residuals \n  - Stats: \n               ┌───────┬────────┬────────┬──────┬────────┬──────┐\n               │ Min.  │ 1st Q. │ Median │ Mean │ 3rd Q. │ Max. │\n               ├───────┼────────┼────────┼──────┼────────┼──────┤\n               │ -1.87 │  -0.24 │   0.02 │ 0.00 │   0.26 │ 1.53 │\n               └───────┴────────┴────────┴──────┴────────┴──────┘\n  - Normality: \n      - Shapiro-Wilks W: 0.971 \n      - p-value        : 4e-04 \n      - Interpretation : Residuals are not normal \n\n  - Spatial autocorrelation: \n             ┌──────────┬───────────┬─────────┬──────────────────┐\n             │ Distance │ Moran's I │ P value │ Interpretation   │\n             ├──────────┼───────────┼─────────┼──────────────────┤\n             │      0.0 │     0.005 │   0.258 │ No spatial       │\n             │          │           │         │ correlation      │\n             └──────────┴───────────┴─────────┴──────────────────┘\n\nVariable importance: \n                         ┌──────────────┬────────────┐\n                         │ Variable     │ Importance │\n                         ├──────────────┼────────────┤\n                         │ lst_night    │      1.966 │\n                         ├──────────────┼────────────┤\n                         │ lst_day      │      1.342 │\n                         ├──────────────┼────────────┤\n                         │ dem          │      1.245 │\n                         ├──────────────┼────────────┤\n                         │ CAMSpm25     │      0.936 │\n                         ├──────────────┼────────────┤\n                         │ coast        │      0.745 │\n                         ├──────────────┼────────────┤\n                         │ ndvi         │      0.683 │\n                         ├──────────────┼────────────┤\n                         │ imd          │      0.420 │\n                         ├──────────────┼────────────┤\n                         │ ntl          │      0.401 │\n                         ├──────────────┼────────────┤\n                         │ industry     │      0.291 │\n                         ├──────────────┼────────────┤\n                         │ popdens      │      0.270 │\n                         ├──────────────┼────────────┤\n                         │ urban        │      0.218 │\n                         ├──────────────┼────────────┤\n                         │ natural      │      0.212 │\n                         ├──────────────┼────────────┤\n                         │ agriculture  │      0.196 │\n                         ├──────────────┼────────────┤\n                         │ otherroads   │      0.181 │\n                         ├──────────────┼────────────┤\n                         │ primaryroads │      0.095 │\n                         └──────────────┴────────────┘\n```\n\n\n:::\n:::\n\n\n\n\nThe `rf_spatial()` returns a **ranger** model with several new slows, most importantly `residuals` that contain information about the residuals, and `spatial` that contains information about the selected spatial predictors and the method used to select them.\nPrinting the model object provides a summary of the model, including its parameters, model performance, information on model residuals, and variable importance. \n\nThe **spatialRF** package also provides a set of additional functions.\nIt includes a function for reducing multicollinearity in the predictors and removing redundant spatial predictors (`filter_spatial_predictors()`); or finding promising variable interactions (`the_feature_engineer()`):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninteractions <- the_feature_engineer(\n    data = temperature_df,\n    dependent.variable.name = response_name,\n    predictor.variable.names = covariate_names,\n    xy = coordinates,\n    importance.threshold = 0.50, # uses 50% best predictors\n    cor.threshold = 0.60, # max corr between interactions and predictors\n    seed = 2025 - 01 - 30,\n    repetitions = 100,\n    verbose = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n ┌──────────────────┬──────────────────┬──────────────────┬──────────────────┐\n │ Interaction      │ Importance (% of │        R-squared │     Max cor with │\n │                  │             max) │      improvement │       predictors │\n ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤\n │ dem..x..CAMSpm25 │             33.6 │            0.020 │            0.52  │\n ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤\n │ dem..x..imd      │             22.1 │            0.014 │            0.54  │\n ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤\n │ imd..pca..ntl    │             13.6 │            0.013 │            0.454 │\n └──────────────────┴──────────────────┴──────────────────┴──────────────────┘\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/misc-sml-10-1.png){width=672}\n:::\n:::\n\n\n\n\nThe `rf_evaluate()` function allows the evaluation of the model using spatial cross-validation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_eval <- rf_evaluate(\n    model = rf_spatial_moran,\n    xy = coordinates,\n    repetitions = 30,\n    training.fraction = 0.75,\n    metrics = \"rmse\",\n    seed = 2025 - 01 - 30,\n    verbose = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nSpatial evaluation \n  - Training fraction:             0.75\n  - Spatial folds:                 30\n\n Metric Median   MAD Minimum Maximum\n   rmse  1.428 0.221   0.815   1.968\n```\n\n\n:::\n\n```{.r .cell-code}\nrf_eval\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel type\n  - Fitted with:                     ranger()\n  - Response variable:               temp\n\nRandom forest parameters\n  - Type:                            Regression\n  - Number of trees:                 500\n  - Sample size:                     195\n  - Number of predictors:            15\n  - Mtry:                            3\n  - Minimum node size:               5\n\n\nModel performance \n  - R squared (oob):                  0.887361\n  - R squared (cor(obs, pred)^2):     0.9844978\n  - Pseudo R squared (cor(obs, pred)):0.9922186\n  - RMSE (oob):                       0.9476691\n  - RMSE:                             0.4131\n  - Normalized RMSE:                  0.103203\n\nModel residuals \n  - Stats: \n               ┌───────┬────────┬────────┬──────┬────────┬──────┐\n               │ Min.  │ 1st Q. │ Median │ Mean │ 3rd Q. │ Max. │\n               ├───────┼────────┼────────┼──────┼────────┼──────┤\n               │ -1.87 │  -0.24 │   0.02 │ 0.00 │   0.26 │ 1.53 │\n               └───────┴────────┴────────┴──────┴────────┴──────┘\n  - Normality: \n      - Shapiro-Wilks W: 0.971 \n      - p-value        : 4e-04 \n      - Interpretation : Residuals are not normal \n\n  - Spatial autocorrelation: \n             ┌──────────┬───────────┬─────────┬──────────────────┐\n             │ Distance │ Moran's I │ P value │ Interpretation   │\n             ├──────────┼───────────┼─────────┼──────────────────┤\n             │      0.0 │     0.005 │   0.258 │ No spatial       │\n             │          │           │         │ correlation      │\n             └──────────┴───────────┴─────────┴──────────────────┘\n\nVariable importance: \n                         ┌──────────────┬────────────┐\n                         │ Variable     │ Importance │\n                         ├──────────────┼────────────┤\n                         │ lst_night    │      1.966 │\n                         ├──────────────┼────────────┤\n                         │ lst_day      │      1.342 │\n                         ├──────────────┼────────────┤\n                         │ dem          │      1.245 │\n                         ├──────────────┼────────────┤\n                         │ CAMSpm25     │      0.936 │\n                         ├──────────────┼────────────┤\n                         │ coast        │      0.745 │\n                         ├──────────────┼────────────┤\n                         │ ndvi         │      0.683 │\n                         ├──────────────┼────────────┤\n                         │ imd          │      0.420 │\n                         ├──────────────┼────────────┤\n                         │ ntl          │      0.401 │\n                         ├──────────────┼────────────┤\n                         │ industry     │      0.291 │\n                         ├──────────────┼────────────┤\n                         │ popdens      │      0.270 │\n                         ├──────────────┼────────────┤\n                         │ urban        │      0.218 │\n                         ├──────────────┼────────────┤\n                         │ natural      │      0.212 │\n                         ├──────────────┼────────────┤\n                         │ agriculture  │      0.196 │\n                         ├──────────────┼────────────┤\n                         │ otherroads   │      0.181 │\n                         ├──────────────┼────────────┤\n                         │ primaryroads │      0.095 │\n                         └──────────────┴────────────┘\n\nSpatial evaluation \n  - Training fraction:             0.75\n  - Spatial folds:                 30\n\n Metric Median   MAD Minimum Maximum\n   rmse  1.428 0.221   0.815   1.968\n```\n\n\n:::\n:::\n\n\n\n\nThe `rf_importance()` function allows for visualizing the variable importance of the model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_imp <- rf_importance(\n    rf_spatial_moran,\n    xy = coordinates\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/misc-sml-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\nrf_imp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel type\n  - Fitted with:                     ranger()\n  - Response variable:               temp\n\nRandom forest parameters\n  - Type:                            Regression\n  - Number of trees:                 500\n  - Sample size:                     195\n  - Number of predictors:            15\n  - Mtry:                            3\n  - Minimum node size:               5\n\n\nModel performance \n  - R squared (oob):                  0.887361\n  - R squared (cor(obs, pred)^2):     0.9844978\n  - Pseudo R squared (cor(obs, pred)):0.9922186\n  - RMSE (oob):                       0.9476691\n  - RMSE:                             0.4131\n  - Normalized RMSE:                  0.103203\n\nModel residuals \n  - Stats: \n               ┌───────┬────────┬────────┬──────┬────────┬──────┐\n               │ Min.  │ 1st Q. │ Median │ Mean │ 3rd Q. │ Max. │\n               ├───────┼────────┼────────┼──────┼────────┼──────┤\n               │ -1.87 │  -0.24 │   0.02 │ 0.00 │   0.26 │ 1.53 │\n               └───────┴────────┴────────┴──────┴────────┴──────┘\n  - Normality: \n      - Shapiro-Wilks W: 0.971 \n      - p-value        : 4e-04 \n      - Interpretation : Residuals are not normal \n\n  - Spatial autocorrelation: \n             ┌──────────┬───────────┬─────────┬──────────────────┐\n             │ Distance │ Moran's I │ P value │ Interpretation   │\n             ├──────────┼───────────┼─────────┼──────────────────┤\n             │      0.0 │     0.005 │   0.258 │ No spatial       │\n             │          │           │         │ correlation      │\n             └──────────┴───────────┴─────────┴──────────────────┘\n\nVariable importance: \n           ┌────────────┬────────────┬─────────┬───────┬──────┬─────┐\n           │ Variable   │ Importance │         │       │      │     │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ lst_night  │      1.966 │  0.13   │ 0.07  │ 15.5 │ 8.4 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ lst_day    │      1.342 │  0.0695 │ 0.035 │  8.3 │ 4.2 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ dem        │      1.245 │  0.045  │ 0.019 │  5.4 │ 2.3 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ CAMSpm25   │      0.936 │ -0.014  │ 0.021 │ -1.7 │ 2.5 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ coast      │      0.745 │ -0.01   │ 0.01  │ -1.2 │ 1.1 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ ndvi       │      0.683 │  0.0055 │ 0.013 │  0.7 │ 1.5 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ imd        │      0.420 │ -0.005  │ 0.004 │ -0.6 │ 0.5 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ ntl        │      0.401 │ -0.007  │ 0.007 │ -0.8 │ 0.8 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ industry   │      0.291 │  0      │ 0.004 │  0   │ 0.4 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ popdens    │      0.270 │ -0.003  │ 0.005 │ -0.4 │ 0.6 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ urban      │      0.218 │ -0.001  │ 0.006 │ -0.1 │ 0.7 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ natural    │      0.212 │ -0.007  │ 0.009 │ -0.8 │ 1.1 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ agricultur │      0.196 │  0      │ 0.008 │  0   │ 1   │\n           │ e          │            │         │       │      │     │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ otherroads │      0.181 │ -0.004  │ 0.004 │ -0.5 │ 0.5 │\n           ├────────────┼────────────┼─────────┼───────┼──────┼─────┤\n           │ primaryroa │      0.095 │ -0.003  │ 0.004 │ -0.4 │ 0.5 │\n           │ ds         │            │         │       │      │     │\n           └────────────┴────────────┴─────────┴───────┴──────┴─────┘\n\nSpatial evaluation \n  - Training fraction:             0.75\n  - Spatial folds:                 30\n\n    Metric Median   MAD Minimum Maximum\n r.squared  0.838 0.073   0.591   0.924\n```\n\n\n:::\n:::\n\n\n\n\nThe `mem()` function generates Moran Eigenvector Maps (MEM) from a distance matrix.^[`mem_multithreshold()` function allows for generating MEMs for multiple distance thresholds.]\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmem1 <- mem(distance.matrix = distance_matrix)\n```\n:::\n\n\n\n\nThe package also contains a set of custom plot functions. \nOne example is the `plot_response_curves()` function, which allows for the visualization of the response curves of the model.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_response_curves(rf_spatial_moran)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/misc-sml-14-1.png){width=672}\n:::\n:::\n\n\n\n\nAdditional interesting functions allow for tuning the model parameters (`rf_tuning()`) or comparing several models (`rf_compare()`).\nA complete list of this package's functions is available at <https://blasbenito.github.io/spatialRF/reference/index.html>.\n\nThe final prediction can be made using the `predict()` function from the **terra** package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_srf <- terra::predict(covariates, rf_spatial_moran)\nterra::plot(pred_srf[[1]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/misc-sml-15-1.png){width=672}\n:::\n:::\n\n\n\n\n# meteo\n\nRandom Forest Spatial Interpolation (RFSI, Sekulić et al. (2020) <doi:10.3390/rs12101687>) is implemented in the **meteo** package.\nRFSI enhances traditional Random Forest by explicitly incorporating spatial autocorrelation through additional covariates. \nThese covariates include (1) observations from the nn nearest locations and (2) their respective distances to the target location. \nPredictions follow the same principle, using the nearest observed values and distances to improve spatial accuracy.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(meteo)\n```\n:::\n\n\n\n\nThis package allows to directly work with spatial R objects.\nFirst, we need to define our formula.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponse_name <- \"temp\"\ncovariate_names <- colnames(temperature)[2:(ncol(temperature) - 8)]\nfo <- as.formula(paste(\n    response_name,\n    \"~\",\n    paste(covariate_names, collapse = \" + \")\n))\n```\n:::\n\n\n\n\nNext, we use the main function in this package, `rfsi()`, to fit the RFSI model.\nThe function requires the formula, the data, and the number of nearest observations used in the model.\nAdditional arguments can be set, including the number of CPUs to use, the progress bar, and arguments passed to the **ranger** function, such as `seed`, `num.trees`, and `mtry`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrfsi_model <- rfsi(\n    formula = fo,\n    data = temperature,\n    n.obs = 5, # number of nearest observations\n    cpus = parallel::detectCores() - 1,\n    progress = FALSE,\n    importance = \"impurity\",\n    seed = 42,\n    num.trees = 250,\n    mtry = 5\n)\nrfsi_model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRanger result\n\nCall:\n ranger(formula, data = data.df, ...) \n\nType:                             Regression \nNumber of trees:                  250 \nSample size:                      195 \nNumber of independent variables:  25 \nMtry:                             5 \nTarget node size:                 5 \nVariable importance mode:         impurity \nSplitrule:                        variance \nOOB prediction error (MSE):       0.9585029 \nR squared (OOB):                  0.8797822 \n```\n\n\n:::\n:::\n\n\n\n\nThe outcome of this function is a standard `ranger` object.\n\nAnother function, `cv.rfsi()`, allows for spatial (leave-location-out) cross-validation of the RFSI model.\nIt requires the formula, the data, the tuning grid, the type of cross-validation, the number of folds, and few other arguments.\nThe `tgrid` argument is a data frame with the tuning parameters to be tested that may include `mtry`, `num.trees`, `n.obs`, and `sample.fraction`.\nHere, we will only tune the `mtry` parameter.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrfsi_model_cv <- cv.rfsi(\n    formula = fo,\n    data = temperature,\n    tgrid = expand.grid(mtry = 3:22),\n    tune.type = \"LLO\", # Leave-Location-Out CV\n    k = 5, # number of folds\n    seed = 42,\n    acc.metric = \"RMSE\", # R2, CCC, MAE\n    output.format = \"sf\", # \"data.frame\", # \"SpatVector\",\n    cpus = parallel::detectCores() - 1,\n    progress = FALSE,\n    importance = \"impurity\"\n) # ranger parameter\nrfsi_model_cv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 195 features and 4 fields\nAttribute-geometry relationships: constant (4)\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 35545.98 ymin: 3988816 xmax: 978546 ymax: 4858816\nProjected CRS: ED50 / UTM zone 30N\nFirst 10 features:\n   staid out.folds       obs      pred                 geometry\n1     10         1 15.619167 15.647846   POINT (978546 4655816)\n2     15         1 13.456851 14.526646   POINT (547546 4784816)\n3     16         1 14.185000 14.624209   POINT (539546 4802816)\n4     17         1 14.306761 14.877302   POINT (498546 4802816)\n5     24         1  7.530117 10.470688   POINT (273546 4762816)\n6     31         1 14.017564 14.943647 POINT (46545.98 4761816)\n7     32         1 14.717808 14.402137 POINT (38545.98 4713816)\n8     41         1 12.313699 12.306969   POINT (543546 4624816)\n9     43         1  8.626575  8.745711   POINT (460546 4560816)\n10    45         1 11.190560 11.511932   POINT (489546 4645816)\n```\n\n\n:::\n\n```{.r .cell-code}\nacc.metric.fun(rfsi_model_cv$obs, rfsi_model_cv$pred, \"RMSE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8828286\n```\n\n\n:::\n:::\n\n\n\n\nThe result is an object of the desired output format (here, a `sf` object) with the observed and predicted values.\nThe `acc.metric.fun()` function can be then use to calculate the accuracy metric (here, RMSE) between the observed and predicted values.\n\nFinally, we can use the `pred.rfsi()` function to predict the model on new data, with a selected output format (here, `SpatRaster`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prediction on new data\nrfsi_prediction <- pred.rfsi(\n    model = rfsi_model,\n    data = temperature,\n    obs.col = \"temp\",\n    newdata = covariates,\n    output.format = \"SpatRaster\", # \"sf\", # \"SpatVector\"\n    cpus = parallel::detectCores() - 1,\n    progress = FALSE\n)\nterra::plot(rfsi_prediction)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/misc-sml-20-1.png){width=672}\n:::\n:::\n\n\n\n\n\n::: {.content-hidden}\n\n## ENMeval\n\n<https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html>\n\nOut-of-scope: a focus on the occurrence records (ecological niche models/species distribution models)\n\n## sits\n\n<https://github.com/e-sensing/sits>\n\nOut-of-scope: a focus on spatiotemporal data cubes\n\n## SpatialML {.}\n\nSpatialML implements a spatial extension of the random forest algorithm (Georganos et al. (2019) <doi:10.1080/10106049.2019.1595177>) based on the **randomForest**, **ranger**, and **caret** packages.\nThis extension is called Geographical Random Forest (GRF).\nIt extends traditional Random Forest by incorporating spatial heterogeneity through local sub-models, where each data point is used to train a localized RF using nearby observations, controlled by an adaptive kernel. \n\nThis package is not described in details here (nor the code is run) as it is aimed at predictions of rather small datasets (e.g., administrative polygons) -- the prediction of the example data takes a long time (~45 minutes).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SpatialML)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoordinates <- sf::st_coordinates(temperature)\ntemperature_df <- sf::st_drop_geometry(temperature)\n\n# define formula\nresponse_name <- \"temp\"\ncovariate_names <- colnames(temperature_df)[2:(ncol(temperature_df) - 7)]\nfo <- as.formula(paste(\n    response_name,\n    \"~\",\n    paste(covariate_names, collapse = \" + \")\n))\n\nsml <- grf(\n    fo,\n    dframe = temperature_df,\n    bw = 8,\n    kernel = \"adaptive\",\n    coords = coordinates\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1\ncovariates_df <- terra::as.data.frame(covariates)\ncovariates_df <- na.omit(covariates_df)\nsml_prediction <- predict.grf(\n    sml,\n    covariates_df,\n    x.var.name = \"X\",\n    y.var.name = \"Y\"\n)\n\n# 2\nsystem.time({\n    sml_prediction <- terra::predict(\n        covariates,\n        sml,\n        fun = predict.grf,\n        x.var.name = \"X\",\n        y.var.name = \"Y\",\n        na.rm = TRUE\n    )\n})\n```\n:::\n\n\n\n\n:::\n\n::: {.callout-note appearance=\"simple\"}\n\nThis blog post was originally written as a supplement to the poster \"An Inventory of Spatial Machine Learning Packages in R\" presented at the FOSSGIS 2025 conference in Muenster, Germany.\nThe poster is available at <https://doi.org/10.5281/zenodo.15088973>.\n\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}