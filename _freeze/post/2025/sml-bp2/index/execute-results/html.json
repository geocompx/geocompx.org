{
  "hash": "8c7337711225ffedcb8612c34b86b9be",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatial Machine Learning with caret\"\nauthor:\n  - name: Jan Linnenbrink\n    url: https://jakubnowosad.com\n    orcid: https://orcid.org/0000-0003-0991-8646\ndate: \"\"\nslug: sml-bp2\ncategories:\n  - rstats\n  - sml\ntags: [caret, CAST, mlr3, tidymodels, machine-learning, spatial-machine-learning]\ndraft: true\nmermaid-format: png\nknitr:\n  opts_chunk:\n    message: false\n---\n\n\n\n\n::: {.callout-note appearance=\"simple\"}\n\nThis is the second part of a blog post series on spatial machine learning with R.\n\nYou can find the list of other blog posts in this series [in part one](post/2025/sml-bp1/).\n\n:::\n\n## Introduction\n\nThis document shows the application of **caret** for spatial modelling at the example of predicting air temperature in Spain.\nHereby, we use measurements of air temperature available only at specific locations in Spain to create a spatially continuous map of air temperature.\nTherefore, machine-learning models are trained to learn the relationship between spatially continuous predictors and air temperature.\n\nWhen using machine-learning methods with spatial data, we need to take care of, e.g., spatial autocorrelation, as well as extrapolation when predicting to regions that are far away from the training data. \nTo deal with these issues, several methods have been developed.\nIn this document, we will show how to combine the machine-learning workflow of **caret** with packages designed to deal with machine-learning with spatial data. Hereby, we use `blockCV::cv_spatial()` and `CAST::knndm()` for spatial cross-validation, and `CAST::aoa()` to mask areas of extrapolation.\nWe use **sf** and **terra** for processing vector and raster data, respectively.\n\n## The caret package\n\nThe **caret** package contains functions to train machine-learning models, as well as for, e.g., model selection. \nIts main function is the `caret::train()`, which provides a uniform interface to over 200 machine-learning algorithms. \n(User-specified-) cross-Validation methods can be defined via `caret::trainControl()`.\nAn extensive online tutorial is available at <https://topepo.github.io/caret/>. \nFurthermore, a paper (<https://doi.org/10.18637/jss.v028.i05>), as well as a book (<http://appliedpredictivemodeling.com/>), describing the use of **caret** are available.\n\n## Install and load required R-packages\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"caret\")\n# install.packages(\"CAST\")\n# install.packages(\"blockCV\")\n# install.packages(\"sf\")\n# install.packages(\"terra\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caret)\nlibrary(CAST)\nlibrary(blockCV)\nlibrary(sf)\nlibrary(terra)\n```\n:::\n\n\n\n\n## Case study data\n\nLoad data needed in this modelling example:\n\n- **predictor stack**: raster dataset of the environmental predictors used to predict air temperature\n- **train points**: vector dataset of ground measurements of air temperature\n- **spain**: region for which predictions are made\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictor_stack <- terra::rast(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/predictors.tif\")\npredictor_names <- names(predictor_stack)\nspain <- sf::st_read(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/spain.gpkg\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `spain' from data source \n  `https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/spain.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1 feature and 0 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13454.15 ymin: 3988025 xmax: 1020771 ymax: 4859816\nProjected CRS: ED50 / UTM zone 30N\n```\n\n\n:::\n\n```{.r .cell-code}\ntrain_points <- sf::st_read(\"https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `temp_train' from data source \n  `https://github.com/LOEK-RS/FOSSGIS2025-examples/raw/refs/heads/main/data/temp_train.gpkg' \n  using driver `GPKG'\nSimple feature collection with 195 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 36026.79 ymin: 3988818 xmax: 978160.6 ymax: 4858999\nProjected CRS: ED50 / UTM zone 30N\n```\n\n\n:::\n\n```{.r .cell-code}\ntrain_data <- terra::extract(\n    predictor_stack,\n    train_points,\n    bind = TRUE,\n    ID = FALSE\n) |>\n    sf::st_as_sf()\n\nplot(sf::st_geometry(spain))\nplot(sf::st_geometry(train_points), col = \"blue4\", add = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n## Standard modelling workflow\n\nFirstly, a simple modelling workflow without feature selection and hyperparameter tuning is shown:\n\n1. split data into training and test data\n2. train model using the training data only\n3. predict on test data to obtain error metrics\n4. predict on predictor stack to obtain spatially continuous prediction of air temperature\n\n::: {.callout-note}\nGeometry column needs to be dropped before using `caret::train()`.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. train-test split\ntrainIndex <- caret::createDataPartition(\n    train_data$temp,\n    p = .8,\n    list = FALSE,\n    times = 1\n)\ntemperature_train <- train_data[trainIndex, ]\ntemperature_test <- train_data[-trainIndex, ]\n\n# 2. model training\nmodel <- caret::train(\n    temp ~ .,\n    data = st_drop_geometry(temperature_train),\n    method = \"ranger\",\n    tuneGrid = expand.grid(\n        \"mtry\" = 4,\n        \"splitrule\" = \"variance\",\n        \"min.node.size\" = 5\n    ),\n    num.trees = 100\n)\n\n# 3. predict on test data\ntest_df <- temperature_test[, \"temp\", drop = FALSE]\ntest_df$prediction <- predict(model, temperature_test)\n\ntest_metrics <- caret::postResample(\n    pred = test_df$prediction,\n    obs = test_df$temp\n) |>\n    round(3) |>\n    t() |>\n    as.data.frame()\n\nprint(test_metrics)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  RMSE Rsquared   MAE\n1 1.16    0.887 0.705\n```\n\n\n:::\n\n```{.r .cell-code}\n# 4. predict to raster stack\nprediction_spatial <- terra::predict(predictor_stack, model, na.rm = TRUE)\n```\n:::\n\n\n\n\n## Spatial Cross-Validation for model selection\n\nCross-validation (CV) methods are often employed to obtain optimal hyperparameter values. \nTherefore, the training data are split into  $k$ folds, and a model is trained on $k$-1 folds. \nThe fold not used for model training is then used to obtain the test statistic. This is repeated over all folds, and the test metric is averaged over the $k$ folds.\n\nIn spatial machine-learning, a spatial CV is often needed to prevent very similar data to be in the training and testing fold at the same time, which is often the case if training data are clustered and leads to overly optimistic CV error estimates.\nR packages that implement spatial CV include, e.g., **blockCV** and **CAST**.\nHere, we will explore the integration of those two with **caret**.\n\n### Hyperparameter tuning using spatial block cross-validation\n\nThe **blockCV** package implements different blocking methods for spatial CV.\nThe resulting object of the main function `blockCV::cv_spatial()` contains a nested list of the $k$ folds and the training data rows that belong to each fold, as well as a list of the test data left out in each of the $k$ iteration. \nThese lists can be obtained using `lapply()` and then be used as an input to the `caret::trainControl()` function of caret that defines the CV strategy used in `caret::train()`. \nThe grid of hyperparameter values tested during CV is defined using the `tune_grid` argument in `caret::train()`. \nHere, we test `mtry` values from 2 to 12 and `min.node.size` values between 5 and 15. \nThe combination of `mtry` and `min.node.size` that minimizes the RMSE is then automatically used to re-train a final model with the complete training data set. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatial_blocks <- blockCV::cv_spatial(\n    temperature_train,\n    k = 5,\n    progress = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  train test\n1   127   32\n2   128   31\n3   127   32\n4   126   33\n5   128   31\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntrain_ids <- lapply(spatial_blocks$folds_list, function(x) x[[1]])\ntest_ids <- lapply(spatial_blocks$folds_list, function(x) x[[2]])\n\ntr_control_block <- caret::trainControl(\n    method = \"cv\",\n    index = train_ids,\n    indexOut = test_ids,\n    savePredictions = TRUE\n)\n\nhyperparameter_grid <- expand.grid(\n    \"mtry\" = c(2, 4, 6, 10, 12),\n    \"min.node.size\" = c(5, 10, 15),\n    \"splitrule\" = \"variance\"\n)\n\nmodel_spatial <- caret::train(\n    temp ~ .,\n    data = st_drop_geometry(temperature_train),\n    method = \"ranger\",\n    trControl = tr_control_block,\n    tuneGrid = hyperparameter_grid,\n    num.trees = 100\n)\n\nmodel_spatial$finalModel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRanger result\n\nCall:\n ranger::ranger(dependent.variable.name = \".outcome\", data = x,      mtry = min(param$mtry, ncol(x)), min.node.size = param$min.node.size,      splitrule = as.character(param$splitrule), write.forest = TRUE,      probability = classProbs, ...) \n\nType:                             Regression \nNumber of trees:                  100 \nSample size:                      159 \nNumber of independent variables:  22 \nMtry:                             10 \nTarget node size:                 10 \nVariable importance mode:         none \nSplitrule:                        variance \nOOB prediction error (MSE):       0.6514647 \nR squared (OOB):                  0.9143746 \n```\n\n\n:::\n:::\n\n\n\n\n### Hyperparameter tuning using target-oriented CV\n\nAnother spatial CV method is kNNDM, which is implemented in the CAST package and aims at emulating the prediction situation encountered by the model during CV. \nIn this case, the prediction situation is to predict from the temperature measurement stations to the whole area of Spain. \nSince the temperature measurement stations are rather randomly distributed over the area of Spain, no spatial blocking is needed and kNNDM randomly assigns training points to CV folds. \nThe output of kNNDM contains a list of row indices of training data points that are used in each CV-iteration (`indx_train`), as well as of indices that are left out in each iteration (`indx_test`).\nThese lists can easily be used as input to the `caret::trainControl()` function of **caret** that defines the CV used in `caret::train()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknndm_folds <- CAST::knndm(\n    tpoints = temperature_train,\n    modeldomain = spain,\n    space = \"geographical\",\n    clustering = \"kmeans\",\n    k = 5\n)\n\ntr_control_knndm <- caret::trainControl(\n    method = \"cv\",\n    index = knndm_folds$indx_train,\n    indexOut = knndm_folds$indx_test,\n    savePredictions = TRUE\n)\n\nhyperparameter_grid <- expand.grid(\n    \"mtry\" = c(2, 4, 6, 10, 12),\n    \"min.node.size\" = c(5, 10, 15),\n    \"splitrule\" = \"variance\"\n)\n\nmodel_knndm <- caret::train(\n    temp ~ .,\n    data = st_drop_geometry(temperature_train),\n    method = \"ranger\",\n    trControl = tr_control_knndm,\n    tuneGrid = hyperparameter_grid,\n    num.trees = 100\n)\n\nmodel_knndm$finalModel\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRanger result\n\nCall:\n ranger::ranger(dependent.variable.name = \".outcome\", data = x,      mtry = min(param$mtry, ncol(x)), min.node.size = param$min.node.size,      splitrule = as.character(param$splitrule), write.forest = TRUE,      probability = classProbs, ...) \n\nType:                             Regression \nNumber of trees:                  100 \nSample size:                      159 \nNumber of independent variables:  22 \nMtry:                             12 \nTarget node size:                 10 \nVariable importance mode:         none \nSplitrule:                        variance \nOOB prediction error (MSE):       0.6953668 \nR squared (OOB):                  0.9086043 \n```\n\n\n:::\n:::\n\n\n\n\n### Feature selection using target-oriented CV\n\nTo reduce the number of environmental predictors, and thus enhance the generalizability of the model, feature selection is commonly applied in machine-learning workflows.\n**CAST** implements Forward-Feature-Selection, that can be used with spatial CV. \nHere, we use the results of the hyperparameter tuning above and kNNDM CV to select the most relevant features. \nPlotting the results of `FFS()` shows that the variables `DEM`, `Y`, `EDF5` and `primaryroads` were selected.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselected_hyperparams <- model_knndm$bestTune\n\nmodel_ffs <- CAST::ffs(\n    predictors = st_drop_geometry(temperature_train)[, predictor_names],\n    response = st_drop_geometry(temperature_train)$temp,\n    method = \"ranger\",\n    num.trees = 100,\n    trControl = tr_control_knndm,\n    tuneGrid = selected_hyperparams,\n    verbose = FALSE\n)\n\nplot(model_ffs, plotType = \"selected\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# obtain prediction\nprediction_ffs <- terra::predict(predictor_stack, model_ffs, na.rm = TRUE)\n```\n:::\n\n\n\n\n## AOA\n\nLastly, the area which is too dissimilar from the training data for the models to make reliable predictions (area of applicability, AOA) is delineated using the function `CAST::aoa()`.\nThe function `CAST::aoa()` takes as inputs the predictor stack, as well as the trained **caret** model. \nThe resulting object contains the Dissimilarity values, the threshold used to delineate the AOA (every DI above this threshold is considered outside the AOA), as well as the final AOA raster.\nSince our training data are randomly distributed in the study area, most of the area falls within the AOA.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAOA_without_tuning <- CAST::aoa(\n    newdata = predictor_stack,\n    model = model,\n    verbose = FALSE\n)\nAOA_with_tuning <- CAST::aoa(\n    newdata = predictor_stack,\n    model = model_ffs,\n    verbose = FALSE\n)\n```\n:::\n\n\n\n\n## Compare predictions obtained by the un-tuned model vs the tuned model\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(2, 2))\nplot(prediction_spatial, main = \"prediction without tuning\")\nplot(AOA_without_tuning$AOA, main = \"AOA without tuning\")\nplot(prediction_ffs, main = \"prediction with model selection\")\nplot(AOA_with_tuning$AOA, main = \"AOA with model selection\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n## Conclusion\n\n**caret** has no functions that explicitly deal with spatial data.\nHowever, due to its rather flexible design, **caret** is compatible with several packages designed for spatial machine-learning. \nThe `caret::trainControl()` takes a list of CV indices as input, which makes it quite flexible to work with the output of e.g. `CAST::knndm()` and `blockCV::cv_spatial()`.\nFurthermore, **caret** is easy to use due to its functional programming paradigm. \nThe documentation is extensive, and it's rather easy to find modelling algorithms and their hyperparameters. \nLastly, it should be noted that **caret** is not actively developed, since its main developer moved to **tidymodels**.\n\n::: {.callout-note appearance=\"simple\"}\n\nThis blog post was originally written as a supplement to the poster \"An Inventory of Spatial Machine Learning Packages in R\" presented at the FOSSGIS 2025 conference in Muenster, Germany.\nThe poster is available at <https://doi.org/10.5281/zenodo.15088973>.\n\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}