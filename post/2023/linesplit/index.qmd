---
title: "Splitting and rasterising linestrings representing transport networks"
# # Alternative title:
# title: "Teaching R and Python for geographic data: shared experiences and lessons learned"
author: 
  - name: Iwo AugustyÅ„ski
    affiliation: Wroclaw Univeristy of Economics and Business, Poland
    orcid: 0000-0003-2145-0484
  - name: Robin Lovelace
    affiliation: University of Leeds, Active Travel England, UK
    orcid: 0000-0001-5679-6536
date: "2023-08-15"
slug: linesplit
categories: 
  - posts
  - rstats
tags: [rspatial]
draft: true
---

The outputs we're looking for are raster datasets with attributes associated with roads and other transport types.

A key message if you're doing this kind of operation on medium to large datasets is: watch out for `st_split()`: in our benchmarks it is very slow.

# Introduction

## Pre-requisites

```{r}
library(sf)
library(dplyr)
```

# Input data

We used the following input datasets and parameters:

- `study_area`: a polygon, the larger the area, the more roads
- Transport network data representing part of Poznan, Poland, where the idea for this blog post originated
- A grid of lines representing the raster cells, defined by `n_cells`: the number of cells in the grid, or the size of the cells in the grid, or a `raster_grid` object

## The case study area

For the case study area we used main roads in Poznan, as shown in the map below.

```{r}
roads_all = osmextract::oe_get("Poznan", extra_tags = "maxspeed", force_vectortranslate = TRUE)
roads = roads_all |>
  filter(highway %in% c("motorway", "primary", "secondary", "tertiary")) |>
  tibble::rowid_to_column()

plot(roads$geometry)
```
The dataset consists of `r nrow(roads)` roads.

## Grid of lines

Set the number of cells in the grid:

```{r}
nrows = 50
ncols = 50

```


```{r}
# One way of creating it:
raster <- terra::rast(nrows = nrows, ncols = ncols, terra::ext(roads), vals = 1)
```

We'll define a function to create the grid, that contains lines that go horizontally and vertically, as follows:

```{r}
#| code-fold: true
raster_to_grid <- function(raster){
  stars::st_as_stars(raster) |> st_as_sf() |> st_cast("POINT") |> # creates five points at the corners of the cell (first point is doubled to close the rectangle)
    tibble::rownames_to_column() |>
    filter(!rowname %in% as.character(1:(nrows*ncols))) |>  # removes duplicated top-left point
    distinct(geometry) |> # removes duplicated points from the adjacent cells
    tibble::rowid_to_column() |>
    group_by(rowid) |> # allows to rowwise execution of st_coordinates
    mutate(x = st_coordinates(geometry)[1],
           y = st_coordinates(geometry)[2]) |>
    ungroup() |>
    mutate(
      position = case_when( # we need only borders
        y == min(y) ~ "top",
        y == max(y) ~ "bottom",
        x == min(x) ~ "left",
        x == max(x) ~ "right")
    ) |>
    filter(!is.na(position)) |> # preserves only points on edges
    group_by(position) |> mutate(id = 1:n()) |> # numbers points in groups for joins
    group_by(id) |>
    mutate(position = case_when( # points must be grouped according to line types not edges
      position %in% c("top", "bottom") ~ "v",
      position %in% c("left", "right") ~ "h"
    )
    ) |>
    group_by(id, position) |>
    summarise(id = mean(id)) |> # points to multipoint
    st_cast("LINESTRING") |>  # multipoint to linestring
    ungroup() |> select(-id) # cleaning
}
```

Construct the grid as follows:

```{r}
grid <- raster_to_grid(raster)
```

We can check that the grid matches roads:

```{r}
plot(grid$geometry, lwd = 3, col = "red")
plot(roads$geometry, lwd = 3, col = "blue", add = TRUE)
```

# Approaches

## 1. Segmentize roads to 100 m fragments
```{r}
##### 1. segmentize
time_st_segmentize = system.time({
  roads_segmented <- st_as_sf(roads, wkt = "geometry", crs = "EPSG:4326") |>
  sf::st_segmentize(dfMaxLength = units::as_units("100 m"))
})
time_st_segmentize
```

## 2. Simple crop roads to the grid with `lwgeom::st_split()` function
```{r}
##### 2. st_split
time_st_split <- system.time({roads_split <- lwgeom::st_split(roads, grid)|>
  sf::st_collection_extract("LINESTRING")})

time_st_split
```


## 3. Crop roads with single lines from the grid
```{r}
##### 3. split_lines
split_lines1 <- function(rds, blades) { #splits roads with blades
  rds <- mutate(rds, rowid = as.factor(rowid))
  rds <- collapse::rsplit(rds, ~ rowid) # data.frame with roads to list
  tmp <- purrr::map(rds,\(x) lwgeom::st_split(x, blades)) |> # split roads line by line
    purrr::list_rbind() |> # resulting list to data.frame
    sf::st_as_sf() |> # data.frame to sf object
    sf::st_collection_extract("LINESTRING") 
}

time_split_lines1 <- system.time({roads_split_lines1 <- split_lines1(roads, grid)})
time_split_lines1
```

## 4. Crop only roads that intersect with the grid
```{r}
##### 4. split_lines2
split_lines2 <- function(x, blades) {
  crosses <- st_filter(x, blades, .predicate = st_crosses)
  others <- filter(x, !osm_id %in% (crosses$osm_id))
  splitted <- lwgeom::st_split(crosses, blades)
  rbind(splitted, others) |> sf::st_collection_extract("LINESTRING")
}

time_split_lines2 <- system.time({roads_split_lines2 <- split_lines2(roads, grid)})
time_split_lines2
```

## 5. Crop using GRAS GIS
```{r}
#### 5. split with GRASS GIS
grass_split <- function(roads, grid){
  vgrid <- terra::vect(stars::st_as_stars(raster) |> st_as_sf())
  vroads <- terra::vect(roads)
  
  rgrass::write_VECT(x = vgrid, vname = "grid")
  rgrass::write_VECT(vroads, "roads")
  rgrass::stringexecGRASS("v.clip input=roads clip=grid output=clipped --overwrite")
  rgrass::read_VECT("clipped") |> st_as_sf()
}

rgrass::initGRASS(gisBase = "/usr/lib/grass78",
  home = tempdir(), 
          SG = raster, 
          override = TRUE)

time_grass <- system.time({roads_split_grass <- grass_split(roads, grid)})
time_grass
```

# Results

```{r}
times_combined <-  rbind(time_st_segmentize, 
      time_st_split, 
      time_split_lines1, 
      time_split_lines2, 
      time_grass) |> as.data.frame() |>
  arrange(elapsed)

knitr::kable(times_combined)


```

The results are not identical 
```{r}
cbind(method = c("Segmentation","Split", "Split 1", "Split 2", "Grass"),
      rbind(nrow(roads_segmented), 
            nrow(roads_split),
            nrow(roads_split_lines1), 
            nrow(roads_split_lines2), 
            nrow(roads_split_grass))
) |>
  knitr::kable(col.names = c("Method", "Number of rows"))
```


Most of the approaches are sensitive to size of a dataset.
```{r}
roads_less = roads_all |>
  filter(highway %in% c("motorway", "primary", "secondary"))

time_st_segmentize_less = system.time({
  roads_segmented_less <- st_as_sf(roads_less, wkt = "geometry", crs = "EPSG:4326") |>
  sf::st_segmentize(dfMaxLength = units::as_units("100 m"))
})

time_st_split_less <- system.time({roads_splitted_less <- lwgeom::st_split(roads_less, grid)|>
  sf::st_collection_extract("LINESTRING")})

roads_less <- tibble::rowid_to_column(roads_less)
time_split_lines1_less <- system.time({roads_split_lines1_less <- split_lines1(roads_less, grid)})

time_split_lines2_less <- system.time({roads_split_lines2_less <- split_lines2(roads_less, grid)})

time_grass_less <- system.time({roads_split_grass_less <- grass_split(roads_less, grid)})


times_combined <- rbind(time_st_segmentize,
      time_st_segmentize_less,
      time_st_split, 
      time_st_split_less,
      time_split_lines1,
      time_split_lines1_less,
      time_split_lines2, 
      time_split_lines2_less,
      time_grass,
      time_grass_less
      ) |> as.data.frame() |> 
  select(elapsed)
times_combined$n_roads <- rep(c(nrow(roads), nrow(roads_less)), 5)      
times_combined$elapsed_per_100_roads <- times_combined$elapsed/times_combined$n_roads*100
  knitr::kable(arrange(times_combined, elapsed_per_100_roads))
```

Surprisingly except of st_split and st_segmentize all methods are faster for bigger dataset. The grass method has probably quite big overhead therefore it gains with size. Simple st_split is most sensitive to the number of lines to crop. Only segmentize is insensitive. 


# Rasterisation

```{r}
# raster grid to vector
grid_u <-  stars::st_as_stars(raster) |> st_as_sf() %>% tibble::rowid_to_column()


rast_length <- function(x){
  st_join(grid_u, select({ x }, length), join = st_covers) %>% 
    group_by(rowid) %>% 
    summarise(sum = sum(length, na.rm = T)) %>% 
    terra::rasterize(raster, field = "sum")
}

rast_split <- rast_length(roads_split)
rast_lines1 <- rast_length(roads_split_lines1)
rast_lines2 <- rast_length(roads_split_lines2)
rast_grass <- rast_length(roads_split_grass)
```


Difference between all roads_split methods and roads_grass:
```{r}
terra::plot(rast_split- rast_grass, type = "interval", breaks = c(6000, 100, 0, -100, -6000), col = c("red", "green", "white", "green", "red"))
terra::plot(terra::vect(roads), add = TRUE)
```
Differences in tabular form
```{r}
lngth <- function(x){
  st_join(grid_u, select({ x }, length), join = st_covers) %>% 
    group_by(rowid) %>% 
    summarise(sum = sum(length, na.rm = T)) %>% 
    filter(sum> units::as_units("0 m")) %>% 
    st_drop_geometry()
}

sum_split <- lngth(roads_split)
# sum_lines1 <- lngth(roads_split_lines1)
# sum_lines2 <- lngth(roads_split_lines2)
sum_grass <- lngth(roads_split_grass)

x <- full_join(sum_split, sum_grass, by = "rowid") %>% mutate(dif = sum.x-sum.y) %>% 
  filter(dif >  units::as_units("1 m") | dif < units::as_units("-1 m"))
filter(x, dif == min(x$dif))
```

LEt's have a closer look at this grid cell:
```{r}
library(tmap)
tmap_mode("view")
g <- select(roads_split_grass, osm_id, length)
g <- st_filter(g, f,  .predicate = st_covered_by)

s <- select(roads_split, osm_id, length)
s <- st_filter(s, f,  .predicate = st_covered_by)

tm_shape(grid_u %>% filter(rowid==1521)) + tm_polygons(col = "violet", alpha = 0.5) +
  tm_shape(g, bbox = bb) +tm_lines(col = "red", scale = 3) +
  tm_shape(s, bbox = bb) +tm_lines(col = "green")
  
```
Sum of roads' length is reported consistently with this picture:
```{r}
sum(s$length)
sum(g$length)
```




# Discussion and next steps

<!---
 # References 
--->



